

import dynamic from "next/dynamic";
import { useRouter } from "next/router";
import { useCallback, useEffect, useMemo, useState } from "react";
import { PublicKey, Transaction } from "@solana/web3.js";
import {
  TOKEN_PROGRAM_ID,
  TOKEN_2022_PROGRAM_ID,
  getMint,
  createBurnCheckedInstruction,
} from "@solana/spl-token";
import { useConnection, useWallet } from "@solana/wallet-adapter-react";

const WalletMultiButton = dynamic(
  async () => (await import("@solana/wallet-adapter-react-ui")).WalletMultiButton,
  { ssr: false }
);
// yoooo what's up welcome to the code for this particular part of this website. I wrote this from scratch with chat gpt 5.2's help over around 100 queries and around 6-8 legitimate hours of work. This was my first time really ever coding anything blockchain transaction related and I truly built this page from the ground up. I'm not sure if it could be simplified more because I ran into many errors along the way trying to get it to really connect but here it is, a very simple burn function with 1000:1 ratio, caps at 1 million circles. This exact blockchain code on this page was the biggest hurdle mentally that I've been facing for the past 6 months since coming up with this idea in regards to preparation. I'd considered hiring someone but I didn't want to invite a lack of security, so here we are. Thank you for reading. I hope you have a wonderful day.

// Replace this with real mint wen launch!!!!!!
const CIRCLE_MINT = new PublicKey("4Fr2LL7tJ52Y6a8g63nHzNqWDjy9Te1H55m8rrX7pump");

const TOKENS_PER_CIRCLE = 1000n;

// Safety limit per transaction
const MAX_CIRCLES_PER_TX = 100000n;
const MAX_CIRCLES_INPUT = 1000000n; // 1 MILLIOOOOOOOONNNNN circles


function isWholeNumberString(s) {
  return /^[0-9]+$/.test(s);
}
function pow10BigInt(n) {
  let r = 1n;
  for (let i = 0; i < n; i++) r *= 10n;
  return r;
}

export default function BurnCircles() {
  const { connection } = useConnection();
  const { publicKey, signTransaction } = useWallet();

  const router = useRouter();

  const [tokenProgramId, setTokenProgramId] = useState(null);
  const [decimals, setDecimals] = useState(null);

  const [rawBalance, setRawBalance] = useState(0n);
  const [circlesAvailable, setCirclesAvailable] = useState(0n);

  const [sourceTokenAccount, setSourceTokenAccount] = useState(null);

  const [circlesStr, setCirclesStr] = useState("");
  const [status, setStatus] = useState("");
  const [txSig, setTxSig] = useState("");

  // Detect token program owner of the mint
  useEffect(() => {
    (async () => {
      try {
        setStatus("Detecting token program‚Ä¶");
        const info = await connection.getAccountInfo(CIRCLE_MINT, "confirmed");
        if (!info) throw new Error("Mint not found (check address).");

        if (info.owner.equals(TOKEN_PROGRAM_ID)) setTokenProgramId(TOKEN_PROGRAM_ID);
        else if (info.owner.equals(TOKEN_2022_PROGRAM_ID)) setTokenProgramId(TOKEN_2022_PROGRAM_ID);
        else throw new Error(`Unknown mint owner program: ${info.owner.toBase58()}`);

        setStatus("");
      } catch (e) {
        setStatus(`Failed to detect token program: ${e?.message ?? String(e)}`);
      }
    })();
  }, [connection]);

  const refresh = useCallback(async () => {
    setTxSig("");
    if (!publicKey || !tokenProgramId) return;

    try {
      setStatus("Loading balances‚Ä¶");

      const mint = await getMint(connection, CIRCLE_MINT, "confirmed", tokenProgramId);
      setDecimals(mint.decimals);

      // ‚úÖ Get ALL token accounts owned by this wallet for this mint (not just ATA)
      const resp = await connection.getParsedTokenAccountsByOwner(
        publicKey,
        { mint: CIRCLE_MINT },
        "confirmed"
      );

      let totalRaw = 0n;
      let bestAcct = null;
      let bestRaw = 0n;

      for (const item of resp.value) {
        const info = item.account.data.parsed.info;
        const amountStr = info.tokenAmount.amount; // raw integer string
        const raw = BigInt(amountStr);

        totalRaw += raw;
        if (raw > bestRaw) {
          bestRaw = raw;
          bestAcct = item.pubkey;
        }
      }

      setRawBalance(totalRaw);
      setSourceTokenAccount(bestAcct);

      const neededPerCircleRaw = TOKENS_PER_CIRCLE * pow10BigInt(mint.decimals);
      setCirclesAvailable(totalRaw / neededPerCircleRaw);

      setStatus("");
    } catch (e) {
      setStatus(`Failed to load token info: ${e?.message ?? String(e)}`);
    }
  }, [connection, publicKey, tokenProgramId]);

  useEffect(() => {
    refresh();
  }, [refresh, publicKey?.toBase58(), tokenProgramId?.toBase58?.()]);

  const burn = useCallback(async () => {
    setTxSig("");

    if (!publicKey) return setStatus("Connect wallet first.");
    if (!signTransaction) return setStatus("Wallet cannot sign.");
    if (!tokenProgramId) return setStatus("Token program not detected yet.");
    if (decimals == null) return setStatus("Token decimals not loaded yet.");
    if (!sourceTokenAccount) return setStatus("No token account found for this mint in your wallet.");

    const s = circlesStr.trim();
    if (!s || !isWholeNumberString(s)) return setStatus("Entire circles only, please! (No decimals 'round here).");

    const circles = BigInt(s);
const egg = 
circles === 1n ? "RESPECT THE CIRCLE" :
circles === 42n ? "The answer to life, the universe, and everything." :  
circles === 67n ? "6 7? What are you, in middle school?" : 
circles === 68n ? "It's like 69 but you give me head and I owe you one..." :
circles === 69n ? "Nice. " :
circles === 360 ? "Is this some kind of joke to you????" : 
circles === 369n ? "3-6-9, dang you fine. Hoping she can text it to me one more time. Get low, get low (get low), get low (get low), get low (get low). To the window (to the window), to the wall (to the wall). 'Til the sweat drop down my armpits (my armpits). 'Til all these respectable young women crawl. (Crawl) 'Til all skate-skate, mamajamma (mamajamma). 'Til all skate-skate, goshdang (goshdang)      Tesla would be so proud.    " :
circles === 420n ? "Grass probably helped me as much as it hurt me. Especially as a performer. When you're high, it's easy to kid yourself about how clever certain mediocre pieces of material are. But, on the other hand, pot opens windows and doors that you may not be able to get through any other way. - George Carlin " : 
circles === 666n ? "Here is wisdom: Let him that hath understanding count the number of the beast, for it is the number of a man; and his number is six hundred threescore and six." : 
circles === 2468n ? "Who do we appreciate?" :
circles === 2701n ? "Wow... you... figured out one of the most important numbers... ever... Like literally mysteries of the universe type shit... I think we have something very incredible in common... keep exploring. You have the divine spark within you." : 
circles ===  
circles === 80085 ? " HEHEHEHEHEHEHEHEHEHE Calculator vibes" : 
circles === 9999n ? " CLOSE BUT NO CIGAR!!! " :
circles === 42069n ? "‚ÄúEverything in excess! To enjoy the flavor of life, take big bites. Moderation is for monks.‚Äù Robert A. Heinlein. " :
circles === 123456n ? "Oh, did you think something super special would happen if you typed this number in or something????" :

"";
const isEgg = egg !== "";
if (isEgg) setStatus(egg.trim());

    if (circles <= 0n) return setStatus("How do you expect to burn 0 circles?");
    if (circles > 999999) return setStatus("I admire your confidence but... come on, dude... Get real.");
    if (circles > circlesAvailable) return setStatus(egg+` You only have ${circlesAvailable} physical circles worth of tokens. I wish you had more, too.`);

    try {
      if (!egg) setStatus("Preparing burn‚Ä¶");
      const amountRaw = circles * TOKENS_PER_CIRCLE * pow10BigInt(decimals);

      const ix = createBurnCheckedInstruction(
        sourceTokenAccount, // burn from the token account that actually holds tokens
        CIRCLE_MINT,
        publicKey,
        amountRaw,
        decimals,
        [],
        tokenProgramId
      );

      const { blockhash } = await connection.getLatestBlockhash("finalized");

      const tx = new Transaction().add(ix);
      tx.feePayer = publicKey;
      tx.recentBlockhash = blockhash;

      if (!egg) setStatus("Requesting signature‚Ä¶");
      const signed = await signTransaction(tx);

      if (!egg) setStatus("Sending‚Ä¶");
      const sig = await connection.sendRawTransaction(signed.serialize(), { skipPreflight: false });
setTxSig(sig);
refresh().catch(() => {});
router.push(`/redeem?sig=${encodeURIComponent(sig)}&circles=${encodeURIComponent(circlesStr.trim())}`);
return;



      setTxSig(sig);
      setStatus("Burn complete üî•");
      await refresh();
    } catch (e) {
      setStatus(`Burn failed: ${e?.message ?? String(e)}`);
    }
  }, [publicKey, signTransaction, tokenProgramId, decimals, circlesStr, circlesAvailable, sourceTokenAccount, connection, refresh]);

  const displayTokens = useMemo(() => {
    if (decimals == null) return "?";
    const div = pow10BigInt(decimals);
    const whole = rawBalance / div;
    const frac = (rawBalance % div).toString().padStart(decimals, "0").slice(0, 6);
    return `${whole.toString()}.${frac}`;
  }, [rawBalance, decimals]);

  const inputIsValid = useMemo(() => {
    const s = circlesStr.trim();
    if (!s) return false;
    if (!isWholeNumberString(s)) return false;
    try {
      return BigInt(s) > 0n;
    } catch {
      return false;
    }
  }, [circlesStr]);

  const circlesBig = useMemo(() => (inputIsValid ? BigInt(circlesStr.trim()) : 0n), [inputIsValid, circlesStr]);

  return (
    <main style={{ maxWidth: 780, margin: "40px auto", padding: 20, textAlign: "center", fontFamily: "system-ui" }}>
      <div style={{ display: "flex", justifyContent: "space-between", textAlign: "center", alignItems: "center", gap: 12 }}>
        <h1 style={{ margin: 0 }}>üî• Burn Circles</h1>
        <WalletMultiButton />
      </div>

      <p>
     <b>1000 CIRCLES token = 1 physical circle</b>.<br /> 1 full sheet = 10,000 physical circles 
      </p>

      <div style={{ border: "1px solid #ddd", borderRadius: 12, padding: 16 }}>
        <div style={{ display: "flex", justifyContent: "center", gap: 16, flexWrap: "wrap" }}>
          <div>
            <span style={{ opacity: 0.7 }}>CIRCLES token:</span>{" "}
            <b>{Number(displayTokens).toLocaleString(undefined, { maximumFractionDigits: 6 })}</b>
          </div>
          <div>
            <span style={{ opacity: 0.7 }}>Physical circles available:</span>{" "}
            <b>{circlesAvailable.toString()}</b>
          </div>
        </div>

        <input
          value={circlesStr}
       onChange={(e) => {
  const v = e.target.value;

  // allow empty
  if (v === "") {
    setCirclesStr("");
    return;
  }

  // digits only
  if (!/^[0-9]+$/.test(v)) return;

  try {
    const n = BigInt(v);

    // cap at 1,000,000
    if (n > MAX_CIRCLES_INPUT) {
      setCirclesStr(MAX_CIRCLES_INPUT.toString());
      return;
    }

    setCirclesStr(v);
  } catch {
    // ignore invalid BigInt
  }
}}

          placeholder="Physical circles (whole number)"
          inputMode="numeric"
          style={{ width: "100%", textAlign: "center", padding: 12, marginTop: 12, borderRadius: 10, border: "1px solid #ccc" }}
        />

        <button
          onClick={burn}
          style={{
            marginTop: 12,
            width: "100%",
            padding: 18,
            borderRadius: 14,
            border: "2px solid #111",
            fontSize: 18,
            fontWeight: 800,
            cursor: "pointer",
          }}
        >
          üî• BURN NOW
        </button>

        {/* ‚úÖ Only show the ‚Äúhow much will burn‚Äù block AFTER a valid input is entered */}
        {inputIsValid && (
          <div style={{ textAlign: "center" }}>
  {inputIsValid && circlesBig % 10000n === 0n && circlesBig >= 10000n && (
  <div
    style={{
      marginTop: 4,
      fontSize: 33,
      fontWeight: 600,
      textAlign: "center",
      letterSpacing: "0.04em",
    }}
  >
    {(circlesBig / 10000n).toString()} FULL SHEET
    {circlesBig / 10000n === 1n ? "" : "S"}
  </div>
)}


            <div style={{ fontSize: 20, fontWeight: 800, marginTop: 10, marginBottom: 8, justifyContent: "center", textAlign: "center" }}>
              {circlesBig.toString()} physical circle{circlesBig === 1n ? "" : "s"} <br />(
              {(circlesBig * 1000n).toString()} CIRCLES token)
            </div>

            <div style={{ fontSize: 13, opacity: 0.75 }}>
              Blockchain transactions are irreversible.<br />Burn at your own risk.<br />
              By clicking this button you confirm that you understand and accept all responsibility.<br />
              <br /><br />
              To redeem your physical circles, you must claim within 24 hours.<br />
              Unclaimed circles will be destroyed.<br /><br />
              Thank you for truly supporting the 1 million circles project.
            </div>
          </div>
        )}

       

        {txSig && (
          <div style={{ marginTop: 10 }}>
            Proof:{" "}
            <a href={`https://solscan.io/tx/${txSig}`} target="_blank" rel="noreferrer">
              View on Solscan
            </a>
          </div>

        )}
      </div>
 {status && <div style={{ marginTop: 10,whiteSpace: "pre-line",
 textAlign: "center" }}>{status}</div>}
    </main>
  );
}